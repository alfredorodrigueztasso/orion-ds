{
  "$schema": "https://orion-ds.dev/schema/registry-item.json",
  "name": "code-editor",
  "type": "registry:component",
  "title": "CodeEditor",
  "description": "CodeEditor component",
  "category": "utilities",
  "files": [
    {
      "path": "packages/react/src/components/CodeEditor/CodeEditor.tsx",
      "type": "registry:component",
      "content": "import React, { forwardRef, useRef, useEffect, useState } from \"react\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport {\n  oneDark,\n  oneLight,\n} from \"react-syntax-highlighter/dist/esm/styles/prism\";\nimport type { CodeEditorProps } from \"./CodeEditor.types\";\nimport { useThemeContext } from \"../../contexts\";\nimport styles from \"./CodeEditor.module.css\";\n\n// Extend markdown grammar with quoted string support\n// This mutation affects react-syntax-highlighter's refractor instance\ntry {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const refractor = require(\"refractor/all\");\n  if (\n    refractor.default &&\n    refractor.default.registered &&\n    refractor.default.registered(\"markdown\") &&\n    !refractor.default.languages.markdown?.[\"quoted-string\"]\n  ) {\n    refractor.default.languages.insertBefore(\"markdown\", \"bold\", {\n      \"quoted-string\": {\n        pattern: /\"(?:\\\\.|[^\"\\\\])*\"/,\n        greedy: true,\n        alias: \"string\",\n      },\n    });\n  }\n} catch {\n  // refractor not available, skip quoted string enhancement\n}\n\n/**\n * CodeEditor\n *\n * A textarea-based code editor with optional syntax highlighting overlay.\n * When language is specified, uses an overlay approach with SyntaxHighlighter.\n * Line numbers are synchronized with scrolling.\n *\n * @example\n * ```tsx\n * const [code, setCode] = useState('# Hello\\nWorld');\n * <CodeEditor\n *   value={code}\n *   onChange={setCode}\n *   language=\"markdown\"\n *   placeholder=\"Enter your code...\"\n *   showLineNumbers\n * />\n * ```\n */\nexport const CodeEditor = forwardRef<HTMLTextAreaElement, CodeEditorProps>(\n  (\n    {\n      value = \"\",\n      onChange,\n      language,\n      readOnly = false,\n      showLineNumbers = true,\n      placeholder,\n      minRows = 10,\n      className,\n      \"aria-label\": ariaLabel,\n      ...rest\n    },\n    ref,\n  ) => {\n    const lineNumbersRef = useRef<HTMLDivElement>(null);\n    const highlightRef = useRef<HTMLDivElement>(null);\n    const mirrorRef = useRef<HTMLDivElement>(null);\n    const editorAreaRef = useRef<HTMLDivElement>(null);\n    const internalTextareaRef = useRef<HTMLTextAreaElement>(null);\n    const nextCursor = useRef<{ start: number; end: number } | null>(null);\n\n    // Use provided ref or internal ref\n    const textareaRef = (ref as React.MutableRefObject<HTMLTextAreaElement | null>) ||\n      internalTextareaRef;\n\n    // Current line tracking for line highlight\n    const [currentLine, setCurrentLine] = useState(0);\n    const [lineHeights, setLineHeights] = useState<number[]>([]);\n\n    // Get theme for syntax highlighting\n    let currentTheme = \"dark\";\n    try {\n      const ctx = useThemeContext();\n      currentTheme = ctx.theme;\n    } catch {\n      // outside ThemeProvider — use dark\n    }\n    const highlightStyle = currentTheme === \"light\" ? oneLight : oneDark;\n\n    // Calculate number of lines\n    const lineCount = Math.max(\n      value.split(\"\\n\").length,\n      minRows,\n    );\n\n    // Restore cursor position after React re-render\n    useEffect(() => {\n      if (nextCursor.current && textareaRef.current) {\n        const { start, end } = nextCursor.current;\n        textareaRef.current.setSelectionRange(start, end);\n        nextCursor.current = null;\n      }\n    });\n\n    // Measure line heights for proper line number alignment with wrapped lines\n    useEffect(() => {\n      const mirror = mirrorRef.current;\n      const editorArea = editorAreaRef.current;\n      if (!mirror || !editorArea) return;\n\n      const measure = () => {\n        const contentWidth = editorArea.clientWidth;\n        if (contentWidth <= 0) return;\n        mirror.style.width = `${contentWidth}px`;\n\n        const lines = value.split(\"\\n\");\n        const totalLines = Math.max(lines.length, minRows);\n        const heights: number[] = [];\n\n        for (let i = 0; i < totalLines; i++) {\n          const line = lines[i] ?? \"\";\n          mirror.textContent = line || \"\\u00a0\";\n          heights.push(mirror.scrollHeight);\n        }\n\n        setLineHeights(heights);\n      };\n\n      measure();\n      const observer = new ResizeObserver(measure);\n      observer.observe(editorArea);\n      return () => observer.disconnect();\n    }, [value, minRows]);\n\n    // Sync scroll position between textarea, line numbers, and highlight layer\n    useEffect(() => {\n      const handleScroll = (event: Event) => {\n        const textarea = event.target as HTMLTextAreaElement;\n        if (lineNumbersRef.current) {\n          lineNumbersRef.current.scrollTop = textarea.scrollTop;\n        }\n        if (highlightRef.current) {\n          highlightRef.current.scrollTop = textarea.scrollTop;\n          highlightRef.current.scrollLeft = textarea.scrollLeft;\n        }\n      };\n\n      const textarea = textareaRef?.current;\n      if (textarea) {\n        textarea.addEventListener(\"scroll\", handleScroll);\n        return () => {\n          textarea.removeEventListener(\"scroll\", handleScroll);\n        };\n      }\n    }, [textareaRef]);\n\n    // Track current line for highlight\n    const updateCurrentLine = (textarea: HTMLTextAreaElement) => {\n      const text = textarea.value.substring(0, textarea.selectionStart);\n      setCurrentLine(text.split(\"\\n\").length - 1);\n    };\n\n    // Handle Tab key insertion (2 spaces)\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n      if (e.key === \"Tab\") {\n        e.preventDefault();\n        const textarea = e.currentTarget;\n        const start = textarea.selectionStart;\n        const end = textarea.selectionEnd;\n        const TAB = \"  \";\n\n        if (start === end) {\n          // No selection: insert 2 spaces at cursor\n          const newValue = value.substring(0, start) + TAB + value.substring(end);\n          nextCursor.current = { start: start + TAB.length, end: start + TAB.length };\n          onChange?.(newValue);\n        } else if (e.shiftKey) {\n          // Shift+Tab: remove up to 2 leading spaces from current line\n          const lineStart = value.lastIndexOf(\"\\n\", start - 1) + 1;\n          const spaces = value.substring(lineStart).match(/^ {1,2}/)?.[0] ?? \"\";\n          if (spaces.length > 0) {\n            const newValue = value.substring(0, lineStart) + value.substring(lineStart + spaces.length);\n            nextCursor.current = {\n              start: Math.max(lineStart, start - spaces.length),\n              end: Math.max(lineStart, end - spaces.length),\n            };\n            onChange?.(newValue);\n          }\n        } else {\n          // Selection: insert TAB at start, keep cursor\n          const newValue = value.substring(0, start) + TAB + value.substring(end);\n          nextCursor.current = { start: start + TAB.length, end: start + TAB.length };\n          onChange?.(newValue);\n        }\n      }\n    };\n\n    const wrapperClasses = [styles.wrapper, className]\n      .filter(Boolean)\n      .join(\" \");\n\n    // When language is specified, use overlay approach with syntax highlighting\n    if (language) {\n      return (\n        <div\n          className={wrapperClasses}\n          style={{ minHeight: `calc(${minRows} * 1.6em + 2 * var(--spacing-4))` }}\n        >\n          {/* Hidden mirror div for measuring visual line heights */}\n          <div ref={mirrorRef} className={styles.lineMirror} aria-hidden=\"true\" />\n\n          {/* Line numbers column */}\n          {showLineNumbers && (\n            <div\n              ref={lineNumbersRef}\n              className={styles.lineNumbers}\n              aria-hidden=\"true\"\n            >\n              {Array.from({ length: lineCount }).map((_, i) => (\n                <div\n                  key={i}\n                  className={styles.lineNumber}\n                  style={lineHeights[i] !== undefined ? { height: `${lineHeights[i]}px` } : undefined}\n                >\n                  {i + 1}\n                </div>\n              ))}\n            </div>\n          )}\n\n          {/* Editor area: highlight layer + textarea overlay */}\n          <div ref={editorAreaRef} className={styles.editorArea}>\n            {/* Line highlight background */}\n            <div\n              className={styles.lineHighlight}\n              style={{\n                top:\n                  lineHeights.length > 0\n                    ? `calc(var(--spacing-4) + ${lineHeights.slice(0, currentLine).reduce((a, b) => a + b, 0)}px)`\n                    : `calc(var(--spacing-4) + ${(currentLine * 1.6).toFixed(2)}em)`,\n                ...(lineHeights[currentLine] !== undefined ? { height: `${lineHeights[currentLine]}px` } : {}),\n              }}\n              aria-hidden=\"true\"\n            />\n\n            {/* Highlight layer — detrás, no interactivo */}\n            <div ref={highlightRef} className={styles.highlightLayer} aria-hidden=\"true\">\n              <SyntaxHighlighter\n                language={language}\n                style={highlightStyle}\n                customStyle={{\n                  margin: 0,\n                  padding: 0,\n                  background: \"transparent\",\n                  fontSize: \"inherit\",\n                  lineHeight: \"inherit\",\n                  fontFamily: \"inherit\",\n                  whiteSpace: \"pre-wrap\",\n                  wordBreak: \"break-word\",\n                  overflow: \"visible\",\n                }}\n                codeTagProps={{\n                  style: {\n                    fontFamily: \"inherit\",\n                    background: \"transparent\",\n                    color: \"var(--text-primary)\",\n                    whiteSpace: \"pre-wrap\",\n                    wordBreak: \"break-word\",\n                  },\n                }}\n              >\n                {value + \"\\n\"}\n              </SyntaxHighlighter>\n            </div>\n\n            {/* Textarea overlay — encima, texto transparente */}\n            <textarea\n              ref={textareaRef}\n              className={styles.textareaOverlay}\n              value={value}\n              onChange={(e) => onChange?.(e.target.value)}\n              onKeyDown={handleKeyDown}\n              onKeyUp={(e) => updateCurrentLine(e.currentTarget)}\n              onMouseUp={(e) => updateCurrentLine(e.currentTarget)}\n              onClick={(e) => updateCurrentLine(e.currentTarget)}\n              placeholder={placeholder}\n              readOnly={readOnly}\n              aria-label={ariaLabel || \"Code editor\"}\n              spellCheck=\"false\"\n              {...rest}\n            />\n          </div>\n        </div>\n      );\n    }\n\n    // Default: plain textarea without syntax highlighting\n    return (\n      <div\n        className={wrapperClasses}\n        style={{ minHeight: `calc(${minRows} * 1.6em + 2 * var(--spacing-4))` }}\n      >\n        {/* Hidden mirror div for measuring visual line heights */}\n        <div ref={mirrorRef} className={styles.lineMirror} aria-hidden=\"true\" />\n\n        {/* Line numbers column */}\n        {showLineNumbers && (\n          <div\n            ref={lineNumbersRef}\n            className={styles.lineNumbers}\n            aria-hidden=\"true\"\n          >\n            {Array.from({ length: lineCount }).map((_, i) => (\n              <div\n                key={i}\n                className={styles.lineNumber}\n                style={lineHeights[i] !== undefined ? { height: `${lineHeights[i]}px` } : undefined}\n              >\n                {i + 1}\n              </div>\n            ))}\n          </div>\n        )}\n\n        {/* Textarea column */}\n        <textarea\n          ref={textareaRef}\n          className={styles.textarea}\n          value={value}\n          onChange={(e) => onChange?.(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder={placeholder}\n          readOnly={readOnly}\n          aria-label={ariaLabel || \"Code editor\"}\n          spellCheck=\"false\"\n          {...rest}\n        />\n      </div>\n    );\n  },\n);\n\nCodeEditor.displayName = \"CodeEditor\";\n"
    },
    {
      "path": "packages/react/src/components/CodeEditor/CodeEditor.types.ts",
      "type": "registry:types",
      "content": "import type { TextareaHTMLAttributes } from \"react\";\n\n/**\n * CodeEditor Props\n * A simple textarea-based code editor with synchronized line numbers.\n */\nexport interface CodeEditorProps\n  extends Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, \"size\" | \"onChange\"> {\n  /**\n   * Current editor content\n   */\n  value?: string;\n\n  /**\n   * Callback when content changes\n   */\n  onChange?: (value: string) => void;\n\n  /**\n   * Language name or type (shown as a badge, informational only)\n   * @default undefined\n   */\n  language?: string;\n\n  /**\n   * Whether the editor is read-only\n   * @default false\n   */\n  readOnly?: boolean;\n\n  /**\n   * Whether to show line numbers on the left\n   * @default true\n   */\n  showLineNumbers?: boolean;\n\n  /**\n   * Placeholder text when empty\n   */\n  placeholder?: string;\n\n  /**\n   * Minimum number of rows to display\n   * @default 10\n   */\n  minRows?: number;\n\n  /**\n   * Additional CSS class name\n   */\n  className?: string;\n\n  /**\n   * Aria label for accessibility\n   */\n  \"aria-label\"?: string;\n}\n"
    },
    {
      "path": "packages/react/src/components/CodeEditor/CodeEditor.module.css",
      "type": "registry:styles",
      "content": "/**\n * CodeEditor Styles\n * Textarea-based code editor with synchronized line numbers\n */\n\n.wrapper {\n  display: flex;\n  flex-direction: row;\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-control);\n  background-color: var(--surface-layer);\n  overflow: hidden;\n  font-family: var(--font-mono);\n  font-size: var(--font-size-13);\n  line-height: 1.6;\n}\n\n.wrapper:focus-within {\n  outline: 2px solid var(--interactive-primary);\n  outline-offset: -2px;\n}\n\n.lineNumbers {\n  flex-shrink: 0;\n  overflow: hidden;\n  background-color: var(--surface-subtle);\n  border-right: 1px solid var(--border-subtle);\n  padding: var(--spacing-4) var(--spacing-2);\n  user-select: none;\n  color: var(--text-tertiary);\n  text-align: right;\n  min-width: auto;\n}\n\n.lineNumber {\n  display: block;\n  min-height: 1.6em;\n  padding: 0 var(--spacing-2);\n  white-space: pre;\n}\n\n.textarea {\n  flex: 1;\n  border: none;\n  outline: none;\n  background-color: transparent;\n  color: var(--text-primary);\n  padding: var(--spacing-4);\n  resize: none;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n  overflow-y: auto;\n  overflow-x: auto;\n}\n\n.textarea::placeholder {\n  color: var(--text-tertiary);\n}\n\n.textarea:disabled {\n  background-color: var(--surface-subtle);\n  color: var(--text-tertiary);\n  cursor: not-allowed;\n}\n\n.textarea::selection {\n  background-color: rgba(99, 153, 255, 0.3);\n  color: transparent;\n}\n\n/* Scrollbar styling (webkit browsers) */\n.textarea::-webkit-scrollbar {\n  width: 6px;\n  height: 6px;\n}\n\n.textarea::-webkit-scrollbar-track {\n  background-color: transparent;\n}\n\n.textarea::-webkit-scrollbar-thumb {\n  background-color: var(--border-subtle);\n  border-radius: 4px;\n}\n\n.textarea::-webkit-scrollbar-thumb:hover {\n  background-color: var(--border-interactive);\n}\n\n.textarea {\n  scrollbar-width: thin;\n  scrollbar-color: var(--border-subtle) transparent;\n}\n\n/* Hidden mirror div for measuring line heights with text wrapping */\n.lineMirror {\n  position: absolute;\n  top: -9999px;\n  left: 0;\n  visibility: hidden;\n  pointer-events: none;\n  white-space: pre-wrap;\n  word-break: break-word;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n  padding: 0;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n\n/* Editor area with highlight layer and textarea overlay */\n.editorArea {\n  position: relative;\n  flex: 1;\n  overflow: hidden;\n}\n\n/* Line highlight background */\n.lineHighlight {\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 1.6em;\n  background-color: var(--surface-layer);\n  pointer-events: none;\n  z-index: var(--z-base);\n}\n\n/* Syntax highlight layer (behind textarea) */\n.highlightLayer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  padding: var(--spacing-4);\n  overflow: auto;\n  box-sizing: border-box;\n  pointer-events: none;\n  user-select: none;\n  white-space: pre-wrap;\n  word-break: break-word;\n  z-index: var(--z-base);\n  scrollbar-width: none;\n}\n\n.highlightLayer::-webkit-scrollbar {\n  display: none;\n}\n\n.highlightLayer::-webkit-scrollbar-track {\n  background-color: transparent;\n}\n\n.highlightLayer::-webkit-scrollbar-thumb {\n  background-color: var(--border-subtle);\n  border-radius: 4px;\n}\n\n/* Textarea overlay (above highlight, transparent text) */\n.textareaOverlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  padding: var(--spacing-4);\n  box-sizing: border-box;\n  border: none;\n  outline: none;\n  resize: none;\n  background: transparent;\n  color: transparent;\n  caret-color: var(--text-primary);\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n  white-space: pre-wrap;\n  word-break: break-word;\n  overflow: auto;\n  z-index: var(--z-modal);\n  scrollbar-width: thin;\n  scrollbar-color: var(--border-subtle) transparent;\n}\n\n.textareaOverlay::placeholder {\n  color: var(--text-tertiary);\n}\n\n.textareaOverlay::-webkit-scrollbar {\n  width: 6px;\n  height: 6px;\n}\n\n.textareaOverlay::-webkit-scrollbar-track {\n  background-color: transparent;\n}\n\n.textareaOverlay::-webkit-scrollbar-thumb {\n  background-color: var(--border-subtle);\n  border-radius: 4px;\n}\n\n.textareaOverlay::selection {\n  background-color: rgba(99, 153, 255, 0.3);\n  color: transparent;\n}\n\n/* Support for reduced motion */\n@media (prefers-reduced-motion: reduce) {\n  .wrapper {\n    outline-offset: 0;\n  }\n}\n"
    },
    {
      "path": "packages/react/src/components/CodeEditor/index.ts",
      "type": "registry:index",
      "content": "export { CodeEditor } from \"./CodeEditor\";\nexport type { CodeEditorProps } from \"./CodeEditor.types\";\n"
    }
  ],
  "props": [
    {
      "name": "value",
      "type": "string",
      "description": "Current editor content"
    },
    {
      "name": "onChange",
      "type": "(value: string) => void",
      "description": "Callback when content changes"
    },
    {
      "name": "language",
      "type": "string",
      "description": "Language name or type (shown as a badge, informational only)",
      "default": "undefined"
    },
    {
      "name": "readOnly",
      "type": "boolean",
      "description": "Whether the editor is read-only",
      "default": false
    },
    {
      "name": "showLineNumbers",
      "type": "boolean",
      "description": "Whether to show line numbers on the left",
      "default": true
    },
    {
      "name": "placeholder",
      "type": "string",
      "description": "Placeholder text when empty"
    },
    {
      "name": "minRows",
      "type": "number",
      "description": "Minimum number of rows to display",
      "default": 10
    },
    {
      "name": "className",
      "type": "string",
      "description": "Additional CSS class name"
    },
    {
      "name": "aria-label",
      "type": "string",
      "description": "Aria label for accessibility",
      "required": true
    }
  ],
  "modeAware": false,
  "preview": {
    "url": "https://orion-ds.dev/library.html#code-editor",
    "local": "/library.html#code-editor"
  },
  "import": "import { CodeEditor } from '@orion-ds/react'",
  "cssImport": "import '@orion-ds/react/styles.css'"
}
