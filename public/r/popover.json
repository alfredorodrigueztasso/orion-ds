{
  "$schema": "https://orion-ds.dev/schema/registry-item.json",
  "name": "popover",
  "type": "registry:component",
  "title": "Popover",
  "description": "Popover component",
  "category": "overlays",
  "files": [
    {
      "path": "packages/react/src/components/Popover/Popover.tsx",
      "type": "registry:component",
      "content": "/**\n * Popover Component\n *\n * A floating panel anchored to a trigger element.\n *\n * @example\n * ```tsx\n * <Popover\n *   trigger={<Button>Click me</Button>}\n *   content={<div>Popover content here</div>}\n *   placement=\"bottom-start\"\n * />\n * ```\n */\n\nimport {\n  forwardRef,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n  cloneElement,\n  isValidElement,\n  useImperativeHandle,\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport type { PopoverProps, PopoverPlacement } from \"./Popover.types\";\nimport styles from \"./Popover.module.css\";\n\n/**\n * Calculate popover position\n */\nconst calculatePosition = (\n  triggerRect: DOMRect,\n  popoverRect: DOMRect,\n  placement: PopoverPlacement,\n  offset: number,\n): { top: number; left: number } => {\n  const scrollX = window.scrollX;\n  const scrollY = window.scrollY;\n\n  let top = 0;\n  let left = 0;\n\n  // Base positions\n  const positions = {\n    top: triggerRect.top + scrollY - popoverRect.height - offset,\n    bottom: triggerRect.bottom + scrollY + offset,\n    left: triggerRect.left + scrollX - popoverRect.width - offset,\n    right: triggerRect.right + scrollX + offset,\n    centerX:\n      triggerRect.left + scrollX + (triggerRect.width - popoverRect.width) / 2,\n    centerY:\n      triggerRect.top + scrollY + (triggerRect.height - popoverRect.height) / 2,\n    startX: triggerRect.left + scrollX,\n    endX: triggerRect.right + scrollX - popoverRect.width,\n    startY: triggerRect.top + scrollY,\n    endY: triggerRect.bottom + scrollY - popoverRect.height,\n  };\n\n  switch (placement) {\n    case \"top\":\n      top = positions.top;\n      left = positions.centerX;\n      break;\n    case \"top-start\":\n      top = positions.top;\n      left = positions.startX;\n      break;\n    case \"top-end\":\n      top = positions.top;\n      left = positions.endX;\n      break;\n    case \"bottom\":\n      top = positions.bottom;\n      left = positions.centerX;\n      break;\n    case \"bottom-start\":\n      top = positions.bottom;\n      left = positions.startX;\n      break;\n    case \"bottom-end\":\n      top = positions.bottom;\n      left = positions.endX;\n      break;\n    case \"left\":\n      top = positions.centerY;\n      left = positions.left;\n      break;\n    case \"left-start\":\n      top = positions.startY;\n      left = positions.left;\n      break;\n    case \"left-end\":\n      top = positions.endY;\n      left = positions.left;\n      break;\n    case \"right\":\n      top = positions.centerY;\n      left = positions.right;\n      break;\n    case \"right-start\":\n      top = positions.startY;\n      left = positions.right;\n      break;\n    case \"right-end\":\n      top = positions.endY;\n      left = positions.right;\n      break;\n  }\n\n  return { top, left };\n};\n\nexport const Popover = forwardRef<HTMLDivElement, PopoverProps>(\n  (\n    {\n      trigger,\n      content,\n      placement = \"bottom\",\n      triggerType = \"click\",\n      open: controlledOpen,\n      defaultOpen = false,\n      onOpenChange,\n      showArrow = true,\n      offset = 8,\n      closeOnClickOutside = true,\n      closeOnEscape = true,\n      openDelay = 0,\n      closeDelay = 150,\n      fullWidth = false,\n      className,\n      ...rest\n    },\n    ref,\n  ) => {\n    const [internalOpen, setInternalOpen] = useState(defaultOpen);\n    const [position, setPosition] = useState({ top: 0, left: 0 });\n\n    const triggerRef = useRef<HTMLDivElement>(null);\n    const popoverRef = useRef<HTMLDivElement>(null);\n    const openTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const closeTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    // Expose the trigger element via ref\n    useImperativeHandle(ref, () => triggerRef.current as HTMLDivElement);\n\n    const isControlled = controlledOpen !== undefined;\n    const isOpen = isControlled ? controlledOpen : internalOpen;\n\n    const setIsOpen = useCallback(\n      (newOpen: boolean) => {\n        if (!isControlled) {\n          setInternalOpen(newOpen);\n        }\n        onOpenChange?.(newOpen);\n      },\n      [isControlled, onOpenChange],\n    );\n\n    // Update position when open\n    const updatePosition = useCallback(() => {\n      if (!triggerRef.current || !popoverRef.current) return;\n\n      const triggerRect = triggerRef.current.getBoundingClientRect();\n      const popoverRect = popoverRef.current.getBoundingClientRect();\n      const newPosition = calculatePosition(\n        triggerRect,\n        popoverRect,\n        placement,\n        offset,\n      );\n      setPosition(newPosition);\n    }, [placement, offset]);\n\n    useEffect(() => {\n      if (isOpen) {\n        // Use requestAnimationFrame to ensure DOM is ready\n        requestAnimationFrame(updatePosition);\n        window.addEventListener(\"resize\", updatePosition);\n        window.addEventListener(\"scroll\", updatePosition, true);\n\n        return () => {\n          window.removeEventListener(\"resize\", updatePosition);\n          window.removeEventListener(\"scroll\", updatePosition, true);\n        };\n      }\n    }, [isOpen, updatePosition]);\n\n    // Handle click outside\n    useEffect(() => {\n      if (!isOpen || !closeOnClickOutside) return;\n\n      const handleClickOutside = (event: MouseEvent) => {\n        const target = event.target as Node;\n        if (\n          triggerRef.current &&\n          !triggerRef.current.contains(target) &&\n          popoverRef.current &&\n          !popoverRef.current.contains(target)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () =>\n        document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, closeOnClickOutside, setIsOpen]);\n\n    // Handle escape key\n    useEffect(() => {\n      if (!isOpen || !closeOnEscape) return;\n\n      const handleEscape = (event: KeyboardEvent) => {\n        if (event.key === \"Escape\") {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"keydown\", handleEscape);\n      return () => document.removeEventListener(\"keydown\", handleEscape);\n    }, [isOpen, closeOnEscape, setIsOpen]);\n\n    // Cleanup timeouts\n    useEffect(() => {\n      return () => {\n        if (openTimeoutRef.current) clearTimeout(openTimeoutRef.current);\n        if (closeTimeoutRef.current) clearTimeout(closeTimeoutRef.current);\n      };\n    }, []);\n\n    // Trigger handlers\n    const handleOpen = useCallback(() => {\n      if (closeTimeoutRef.current) clearTimeout(closeTimeoutRef.current);\n      if (openDelay > 0) {\n        openTimeoutRef.current = setTimeout(() => setIsOpen(true), openDelay);\n      } else {\n        setIsOpen(true);\n      }\n    }, [openDelay, setIsOpen]);\n\n    const handleClose = useCallback(() => {\n      if (openTimeoutRef.current) clearTimeout(openTimeoutRef.current);\n      if (closeDelay > 0) {\n        closeTimeoutRef.current = setTimeout(\n          () => setIsOpen(false),\n          closeDelay,\n        );\n      } else {\n        setIsOpen(false);\n      }\n    }, [closeDelay, setIsOpen]);\n\n    const handleToggle = useCallback(() => {\n      if (isOpen) {\n        handleClose();\n      } else {\n        handleOpen();\n      }\n    }, [isOpen, handleOpen, handleClose]);\n\n    // Build trigger props based on trigger type\n    const getTriggerProps = () => {\n      const baseProps: Record<string, unknown> = {\n        \"aria-expanded\": isOpen,\n        \"aria-haspopup\": true,\n      };\n\n      switch (triggerType) {\n        case \"click\":\n          return { ...baseProps, onClick: handleToggle };\n        case \"hover\":\n          return {\n            ...baseProps,\n            onMouseEnter: handleOpen,\n            onMouseLeave: handleClose,\n          };\n        case \"focus\":\n          return {\n            ...baseProps,\n            onFocus: handleOpen,\n            onBlur: handleClose,\n          };\n        case \"manual\":\n          return baseProps;\n        default:\n          return baseProps;\n      }\n    };\n\n    // Clone trigger with props\n    const triggerElement = isValidElement(trigger)\n      ? cloneElement(\n          trigger as React.ReactElement<Record<string, unknown>>,\n          getTriggerProps(),\n        )\n      : trigger;\n\n    // Get arrow direction based on placement\n    const getArrowPlacement = () => {\n      if (placement.startsWith(\"top\")) return \"bottom\";\n      if (placement.startsWith(\"bottom\")) return \"top\";\n      if (placement.startsWith(\"left\")) return \"right\";\n      if (placement.startsWith(\"right\")) return \"left\";\n      return \"top\";\n    };\n\n    const popoverClasses = [styles.popover, isOpen && styles.visible, className]\n      .filter(Boolean)\n      .join(\" \");\n\n    const popoverElement = (\n      <div\n        ref={popoverRef}\n        className={popoverClasses}\n        style={{\n          top: position.top,\n          left: position.left,\n        }}\n        role=\"dialog\"\n        aria-modal=\"false\"\n        onMouseEnter={triggerType === \"hover\" ? handleOpen : undefined}\n        onMouseLeave={triggerType === \"hover\" ? handleClose : undefined}\n        {...rest}\n      >\n        {showArrow && (\n          <div\n            className={`${styles.arrow} ${styles[`arrow-${getArrowPlacement()}`]}`}\n            aria-hidden=\"true\"\n          />\n        )}\n        <div className={styles.content}>{content}</div>\n      </div>\n    );\n\n    const triggerClasses = [\n      styles.trigger,\n      fullWidth && styles.triggerFullWidth,\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    return (\n      <>\n        <div ref={triggerRef} className={triggerClasses}>\n          {triggerElement}\n        </div>\n        {isOpen && createPortal(popoverElement, document.body)}\n      </>\n    );\n  },\n);\n\nPopover.displayName = \"Popover\";\n"
    },
    {
      "path": "packages/react/src/components/Popover/Popover.types.ts",
      "type": "registry:types",
      "content": "/**\n * Popover Component Types\n *\n * Type definitions for the Orion Popover component.\n */\n\nimport type { HTMLAttributes, ReactNode, RefObject } from \"react\";\n\n/**\n * Popover placement options\n */\nexport type PopoverPlacement =\n  | \"top\"\n  | \"top-start\"\n  | \"top-end\"\n  | \"bottom\"\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"left\"\n  | \"left-start\"\n  | \"left-end\"\n  | \"right\"\n  | \"right-start\"\n  | \"right-end\";\n\n/**\n * Popover trigger types\n */\nexport type PopoverTrigger = \"click\" | \"hover\" | \"focus\" | \"manual\";\n\n/**\n * Popover component props\n *\n * @example\n * ```tsx\n * <Popover\n *   trigger={<Button>Open</Button>}\n *   content={<div>Popover content</div>}\n * />\n * ```\n */\nexport interface PopoverProps extends Omit<\n  HTMLAttributes<HTMLDivElement>,\n  \"content\"\n> {\n  /**\n   * The trigger element that opens the popover\n   */\n  trigger: ReactNode;\n\n  /**\n   * The content to display in the popover\n   */\n  content: ReactNode;\n\n  /**\n   * Placement of the popover relative to the trigger\n   * @default 'bottom'\n   */\n  placement?: PopoverPlacement;\n\n  /**\n   * How to trigger the popover\n   * @default 'click'\n   */\n  triggerType?: PopoverTrigger;\n\n  /**\n   * Whether the popover is open (controlled mode)\n   */\n  open?: boolean;\n\n  /**\n   * Default open state (uncontrolled mode)\n   * @default false\n   */\n  defaultOpen?: boolean;\n\n  /**\n   * Callback when open state changes\n   */\n  onOpenChange?: (open: boolean) => void;\n\n  /**\n   * Whether to show an arrow pointing to the trigger\n   * @default true\n   */\n  showArrow?: boolean;\n\n  /**\n   * Offset from the trigger in pixels\n   * @default 8\n   */\n  offset?: number;\n\n  /**\n   * Whether to close when clicking outside\n   * @default true\n   */\n  closeOnClickOutside?: boolean;\n\n  /**\n   * Whether to close when pressing Escape\n   * @default true\n   */\n  closeOnEscape?: boolean;\n\n  /**\n   * Delay before showing (for hover trigger)\n   * @default 0\n   */\n  openDelay?: number;\n\n  /**\n   * Delay before hiding (for hover trigger)\n   * @default 150\n   */\n  closeDelay?: number;\n\n  /**\n   * Whether the trigger wrapper should stretch to fill its container\n   * Set to true when Popover is placed inside a constrained container (e.g., sidebar header)\n   * Changes trigger from display: inline-block to display: block with width: 100%\n   * @default false\n   */\n  fullWidth?: boolean;\n}\n\n/**\n * Internal hook return type\n */\nexport interface UsePopoverReturn {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  triggerRef: RefObject<HTMLDivElement | null>;\n  popoverRef: RefObject<HTMLDivElement | null>;\n  triggerProps: Record<string, unknown>;\n  popoverProps: Record<string, unknown>;\n}\n"
    },
    {
      "path": "packages/react/src/components/Popover/Popover.module.css",
      "type": "registry:styles",
      "content": "/**\n * Popover Component Styles\n *\n * Uses CSS Modules for scoped styling.\n * All values reference semantic tokens via CSS variables.\n */\n\n/* Component-level tokens */\n:root {\n  --popover-arrow-size: 10px;\n  --popover-arrow-offset: 6px;\n  --popover-arrow-margin: 5px;\n}\n\n/* Trigger wrapper */\n.trigger {\n  display: inline-block;\n}\n\n/* Trigger full-width modifier */\n.triggerFullWidth {\n  display: block;\n  width: 100%;\n  min-width: 0;\n}\n\n/* Popover container */\n.popover {\n  position: absolute;\n  z-index: var(--z-popover);\n  min-width: 200px;\n  max-width: 320px;\n  background: var(--surface-base);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-control);\n  box-shadow: var(--shadow-lg);\n  opacity: 0;\n  visibility: hidden;\n  transform: scale(0.95);\n  transition:\n    opacity var(--transition-fast),\n    transform var(--transition-fast),\n    visibility 0s linear var(--transition-fast);\n}\n\n.visible {\n  opacity: 1;\n  visibility: visible;\n  transform: scale(1);\n  transition:\n    opacity var(--transition-fast),\n    transform var(--transition-fast),\n    visibility 0s linear 0s;\n}\n\n/* Content */\n.content {\n  padding: var(--spacing-4);\n  font-family: var(--font-secondary);\n  font-size: var(--font-size-14);\n  color: var(--text-primary);\n}\n\n/* ============================================================================\n * ARROW\n * ============================================================================ */\n\n.arrow {\n  position: absolute;\n  width: var(--popover-arrow-size);\n  height: var(--popover-arrow-size);\n  background: var(--surface-base);\n  border: 1px solid var(--border-subtle);\n  transform: rotate(45deg);\n}\n\n/* Arrow positions */\n.arrow-top {\n  top: calc(var(--popover-arrow-offset) * -1);\n  left: 50%;\n  margin-left: calc(var(--popover-arrow-margin) * -1);\n  border-right: none;\n  border-bottom: none;\n}\n\n.arrow-bottom {\n  bottom: calc(var(--popover-arrow-offset) * -1);\n  left: 50%;\n  margin-left: calc(var(--popover-arrow-margin) * -1);\n  border-left: none;\n  border-top: none;\n}\n\n.arrow-left {\n  left: calc(var(--popover-arrow-offset) * -1);\n  top: 50%;\n  margin-top: calc(var(--popover-arrow-margin) * -1);\n  border-right: none;\n  border-top: none;\n}\n\n.arrow-right {\n  right: calc(var(--popover-arrow-offset) * -1);\n  top: 50%;\n  margin-top: calc(var(--popover-arrow-margin) * -1);\n  border-left: none;\n  border-bottom: none;\n}\n\n/* ============================================================================\n * REDUCED MOTION\n * ============================================================================ */\n\n@media (prefers-reduced-motion: reduce) {\n  .popover {\n    transition: none;\n  }\n}\n"
    },
    {
      "path": "packages/react/src/components/Popover/index.ts",
      "type": "registry:index",
      "content": "/**\n * Popover Component - Contextual content overlay.\n *\n * @example\n * ```tsx\n * import { Popover, Button } from '@orion-ds/react';\n *\n * <Popover\n *   trigger={<Button>Open Menu</Button>}\n *   content={\n *     <div>\n *       <p>Popover content here</p>\n *       <Button size=\"sm\">Action</Button>\n *     </div>\n *   }\n *   placement=\"bottom\"\n * />\n * ```\n */\nexport { Popover } from \"./Popover\";\nexport type {\n  PopoverProps,\n  PopoverPlacement,\n  PopoverTrigger,\n} from \"./Popover.types\";\n"
    }
  ],
  "props": [
    {
      "name": "trigger",
      "type": "ReactNode",
      "description": "The trigger element that opens the popover",
      "required": true
    },
    {
      "name": "content",
      "type": "ReactNode",
      "description": "The content to display in the popover",
      "required": true
    },
    {
      "name": "placement",
      "type": "PopoverPlacement",
      "description": "Placement of the popover relative to the trigger",
      "default": "bottom",
      "values": [
        "top",
        "top-start",
        "top-end",
        "bottom",
        "bottom-start",
        "bottom-end",
        "left",
        "left-start",
        "left-end",
        "right",
        "right-start",
        "right-end"
      ]
    },
    {
      "name": "triggerType",
      "type": "PopoverTrigger",
      "description": "How to trigger the popover",
      "default": "click",
      "values": [
        "click",
        "hover",
        "focus",
        "manual"
      ]
    },
    {
      "name": "open",
      "type": "boolean",
      "description": "Whether the popover is open (controlled mode)"
    },
    {
      "name": "defaultOpen",
      "type": "boolean",
      "description": "Default open state (uncontrolled mode)",
      "default": false
    },
    {
      "name": "onOpenChange",
      "type": "(open: boolean) => void",
      "description": "Callback when open state changes"
    },
    {
      "name": "showArrow",
      "type": "boolean",
      "description": "Whether to show an arrow pointing to the trigger",
      "default": true
    },
    {
      "name": "offset",
      "type": "number",
      "description": "Offset from the trigger in pixels",
      "default": 8
    },
    {
      "name": "closeOnClickOutside",
      "type": "boolean",
      "description": "Whether to close when clicking outside",
      "default": true
    },
    {
      "name": "closeOnEscape",
      "type": "boolean",
      "description": "Whether to close when pressing Escape",
      "default": true
    },
    {
      "name": "openDelay",
      "type": "number",
      "description": "Delay before showing (for hover trigger)",
      "default": 0
    },
    {
      "name": "closeDelay",
      "type": "number",
      "description": "Delay before hiding (for hover trigger)",
      "default": 150
    },
    {
      "name": "fullWidth",
      "type": "boolean",
      "description": "Whether the trigger wrapper should stretch to fill its container",
      "default": false
    }
  ],
  "tokens": [
    "--surface-base",
    "--border-subtle",
    "--radius-control",
    "--shadow-lg"
  ],
  "examples": [
    {
      "title": "Basic popover",
      "code": "<Popover\n  trigger={<Button variant=\"ghost\">Info</Button>}\n  content={<div>Detailed information here</div>}\n/>"
    }
  ],
  "modeAware": false,
  "preview": {
    "url": "https://orion-ds.dev/library.html#popover",
    "local": "/library.html#popover"
  },
  "import": "import { Popover } from '@orion-ds/react'",
  "cssImport": "import '@orion-ds/react/styles.css'"
}
